<?php

/**
 * Implements hook_menu().
 */
function sprowt_taxonomy_engine_menu(){
	$items = array();

	$items['admin/config/sprowt/lb-generate-aliases'] = array(
		'title' => 'Regenerate Aliases',
		'page callback' => 'drupal_get_form',
		'page arguments' => array('_sprowt_taxonomy_engine_generate_aliases'),
		'access arguments' => array('access administration pages'),
		'file' => 'sprowt_taxonomy_engine.pages.inc',
		'type' =>  MENU_NORMAL_ITEM
	);
    
    $items['admin/config/sprowt/unlock-types'] = array(
        'title' => 'Unlock URL Aliases',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('_sprowt_taxonomy_engine_unlock_types'),
        'access arguments' => array('access administration pages'),
        'file' => 'sprowt_taxonomy_engine.pages.inc',
        'type' =>  MENU_NORMAL_ITEM
    );
    

	return $items;
}

/**
 * Implements hook_form_alter().
 *
 * This function disables typical manipulation of the content types 
 * so that they can be controlled by taxonomy terms exclusively.
 */
function sprowt_taxonomy_engine_form_alter(&$form, &$form_state) {
	$allowable_form_ids = array('localtarget_node_form', 'market_node_form', 'service_node_form', 'region_node_form');
	$allowable_node_types = array('localtarget', 'service', 'market', 'region');

	//Prevent manual add operations
	$disallowed_actions = array();
	foreach ($allowable_node_types as $type) {
		$disallowed_actions[] = "/node/add/$type";
	}
	if (in_array($form['#action'], $disallowed_actions)) {
		drupal_set_message(t('Cannot add content type directly! All LocalTarget, Service, Market, and Region add operations are handled through the Services, Markets, and Regions taxonomy.'), 'error');
		drupal_goto('admin/content');
		return;
	}
	//Disable node delete link and appropriate form elements
	//Standard items
	if (in_array($form['#form_id'], $allowable_form_ids)) {
		$form['title']['#disabled'] = TRUE;
		unset($form['actions']['delete']);
        $type = $form['type']['#value'];
        $unlocked = variable_get('sprowt_taxonomy_engine_unlocked_types', array());
        if(!in_array($type, $unlocked)) {
            $form['path']['alias']['#disabled'] = TRUE;
            $form['path']['pathauto']['#disabled'] = TRUE;
            $form['path']['pathauto']['#checked'] = TRUE;
        }
	}
	//Unique items
	switch ($form['#form_id']) {
		case 'region_node_form':
			$form['field_region']['#disabled'] = TRUE;
			break;
		case 'service_node_form':
			$form['field_service']['#disabled'] = TRUE;
			break;
		case 'market_node_form':
			$form['field_market']['#disabled'] = TRUE;
			break;
		case 'localtarget_node_form':
			$form['field_service']['#disabled'] = TRUE;
			$form['field_market']['#disabled'] = TRUE;
			break;
	}
	
	//If users reach delete confirmation page for service/local target page, redirect them with error message
	$error_type = '';
	if ($form['#form_id'] == 'node_delete_confirm' && isset($form['#node']->type)) {
		if (in_array($form['#node']->type, $allowable_node_types)) {
			$error_type = $form['#node']->type;
		}
	}
	//Account for a batch delete
	elseif ($form['#form_id'] =='node_admin_content' && 
		$form['#theme'] == 'confirm_form' && 
		$form['operation']['#value'] == 'delete' &&
		isset($form['nodes'])) {
		foreach ($form['nodes'] as $nid_key => $nid) {
			if (is_numeric($nid_key)) {
				$node = node_load($nid_key);
				if (in_array($node->type, $allowable_node_types)) {
					$error_type = $node->type;
					break;
				}
			}
		}
	}

	if (!empty($error_type)) {
		switch ($error_type) {
			case 'region':
				$message = 'Cannot delete Region node directly! All Region add/delete operations are handled through the Regions taxonomy.';
				break;
			case 'service':
				$message = 'Cannot delete Service node directly! All Service add/delete operations are handled through the Services taxonomy.';
				break;
			case 'market':
				$message = 'Cannot delete Market node directly! All Market add/delete operations are handled through the Markets taxonomy.';
				break;
			case 'localtarget':
				$message = 'Cannot delete LocalTarget node directly! All LocalTarget add/delete operations are handled through the Services and Markets taxonomies.';
				break;
		}
		drupal_set_message(t($message), 'error');
		drupal_goto('admin/content');
	}

	//Prevent deletion of vocabularies, hide form elements like machine name and delete link
	$locked_vocabularies = array('regions', 'services', 'markets');
	if ($form['#form_id'] == 'taxonomy_form_vocabulary') {
		if (in_array($form['#vocabulary']->machine_name, $locked_vocabularies)) {
			//Redirect if trying to delete vocabulary
			if (isset($form['actions']['submit']['#value']) && $form['actions']['submit']['#value'] == 'Delete') {
				drupal_set_message(t('Cannot delete '.$form['#vocabulary']->name
.'!'), 'error');
				drupal_goto('admin/structure/taxonomy/'.$form['#vocabulary']->machine_name);
			}
			//Disable changing the machine name
			if (isset($form['machine_name'])) {
				$form['machine_name']['#disabled'] = TRUE;
			}
			//Remove delete link
			if (isset($form['actions']['delete'])) {
				unset($form['actions']['delete']);
			}
		}
	}

	//Add messages and validation to appropriate taxonomy term form pages
	if ($form['#form_id'] == 'taxonomy_form_term') {
		if (in_array($form['#vocabulary']->machine_name, $locked_vocabularies)) {
			if (isset($form['actions']['submit']['#value'])) {
				$message = '';
				switch ($form['actions']['submit']['#value']) {
					case 'Delete':
						$form['description']['#markup'] = '';
						$message = '<strong>WARNING: Deleting a '.$form['#vocabulary']->name.' term will also delete all associated '.substr($form['#vocabulary']->name, 0, strlen($form['#vocabulary']->name)-1).' nodes';
						if ($form['#vocabulary']->machine_name == 'markets' || $form['#vocabulary']->machine_name == 'services') {
							$message .= ', along with all LocalTarget nodes linked to this term';
						}
						$message .= '! This action cannot be undone.</strong>';
						break;
					case 'Save':
						$message = '<strong>IMPORTANT: Remember that creating/altering '.$form['#vocabulary']->name.' terms will create/alter associated '.substr($form['#vocabulary']->name, 0, strlen($form['#vocabulary']->name)-1).' nodes';
						if ($form['#vocabulary']->machine_name == 'markets' || $form['#vocabulary']->machine_name == 'services') {
							$message .= ', along with creating/altering all LocalTarget nodes associated with this term';
						}
						$message .= '!</strong>';
						//Add term validation function preventing " in " strings in markets and services vocabs
						if ($form['#vocabulary']->machine_name == 'services' || $form['#vocabulary']->machine_name == 'markets') {
							$form['#validate'][] = '_sprowt_taxonomy_engine_validate';
						}
						break;
				}
				$form['#prefix'] = $message;
			}
		}
	}
	
	//Pathauto settings
	
	if($form['#form_id'] == 'pathauto_patterns_form') {
		$form['node']['pathauto_node_localtarget_pattern']['#disabled'] = true;
		$form['node']['pathauto_node_localtarget_pattern']['#value'] = variable_get('pathauto_node_localtarget_pattern','[node:title]');
	}
}

function _sprowt_taxonomy_engine_validate($form, &$form_state) {
	if (strpos($form_state['values']['name'], ' in ') !== FALSE) {
		form_set_error('name', 'Name cannot contain the string " in "');
	}
}

/**
 * Implements hook_taxonomy_term_update().
 *
 * Manage syncing with region/service/Market/local target pages via taxonomy updates
 */
function sprowt_taxonomy_engine_taxonomy_term_update($term) {
	if (($term->vocabulary_machine_name == 'services' || $term->vocabulary_machine_name == 'markets') && !is_null($term->tid)) {
		//Sync Service titles with taxonomy title first if a services term
		if ($term->vocabulary_machine_name == 'services') {
			$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('service', $term->tid);
			foreach (node_load_multiple($nids) as $node) {
				if ($node->title != $term->name) {
					$node->title = $term->name;
					node_save($node);
					watchdog('sprowt_taxonomy_engine', 'Updated Service node '.$node->nid.' title to match updated services taxonomy term name: '.$node->title);
				}
			}
		}
		elseif ($term->vocabulary_machine_name == 'markets') {
			$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('market', $term->tid);
			foreach (node_load_multiple($nids) as $node) {
				if ($node->title != $term->name) {
					$node->title = $term->name;
					node_save($node);
					watchdog('sprowt_taxonomy_engine', 'Updated Market node '.$node->nid.' title to match updated Markets taxonomy term name: '.$node->title);
				}
			}
		}

		//Sync LTP titles with taxonomy title
		$ltp_data = _sprowt_taxonomy_engine_get_existing_ltps(true); //Want lookup table as well
		$nids = $ltp_data['nids'];
		$ltp_lookup_table = $ltp_data['ltp_lookup_table'];

		foreach (node_load_multiple($nids) as $node) {
			if ($term->vocabulary_machine_name == 'services') {	
				if (isset($node->field_service['und'][0]['tid'])) {
					//If node has saved tid, update the title if necessary
					if ($node->field_service['und'][0]['tid'] == $term->tid) {				
						$title_tokens = explode(' in ', $node->title);
						if ($title_tokens[0] != $term->name) {
							$node->title = $term->name.' in '.$title_tokens[1];
							node_save($node);
							watchdog('sprowt_taxonomy_engine', 'Updated LocalTarget node '.$node->nid.' title to match updated services taxonomy term name: '.$node->title);
						}
					}
				}
				else {
					watchdog('sprowt_taxonomy_engine', 'Service node '.$node->nid.' ('.$node->title.') has no service term assigned!', array(), WATCHDOG_WARNING);
				}
			}
			elseif ($term->vocabulary_machine_name == 'markets') {
				if (isset($node->field_market['und'][0]['tid'])) {
					//If node has saved tid, update the title if necessary
					if ($node->field_market['und'][0]['tid'] == $term->tid) {				
						$title_tokens = explode(' in ', $node->title);
						if ($title_tokens[1] != $term->name) {
							$node->title = $title_tokens[0].' in '.$term->name;
							node_save($node);
							watchdog('sprowt_taxonomy_engine', 'Updated LocalTarget node '.$node->nid.' title to match updated Markets taxonomy term name: '.$node->title);
						}
					}
				}
				else {
					watchdog('sprowt_taxonomy_engine', 'Service node '.$node->nid.' ('.$node->title.') has no Market term assigned!', array(), WATCHDOG_WARNING);
				}
			}
		}

		//Now, determine which new LTPs need to be created and create them!
		//Having this thorough loop ensures that if any LTPs are missing, they will be recreated here
		$all_service_terms = taxonomy_get_tree(taxonomy_vocabulary_machine_name_load('services')->vid);
		$all_market_terms = taxonomy_get_tree(taxonomy_vocabulary_machine_name_load('markets')->vid);
		foreach ($all_service_terms as $this_service_term) {
			foreach ($all_market_terms as $this_market_term) {
				if (!isset($ltp_lookup_table[$this_service_term->tid][$this_market_term->tid])) {
					//Create new LTP!
					$properties = array(
						'title' => $this_service_term->name.' in '.$this_market_term->name,
						'services_tid' => $this_service_term->tid,
						'markets_tid' => $this_market_term->tid,
					);
					if ($newNode = _sprowt_taxonomy_engine_build_node('localtarget', $properties)) {
						node_save($newNode);
						watchdog('sprowt_taxonomy_engine', 'Created LocalTarget node '.$newNode->nid.' ('.$newNode->title.')');
					}
					else { //function returns NULL if malformed! Escape before more damange is done
						watchdog('sprowt_taxonomy_engine', 'Failed to create LocalTarget node (title: '.$properties['title'].'). Check node properties.', array(), WATCHDOG_ERROR);
						return;
					}
				}
			}
		}
	}
	//Update Region titles
	elseif ($term->vocabulary_machine_name == 'regions' && !is_null($term->tid)) {
		$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('region', $term->tid);
		foreach (node_load_multiple($nids) as $node) {
			if ($node->title != $term->name) {
				$node->title = $term->name;
				node_save($node);
				watchdog('sprowt_taxonomy_engine', 'Updated Region node '.$node->nid.' title to match updated regions taxonomy term name: '.$node->title);
			}
		}
	}
}

/**
 * Implements hook_taxonomy_term_insert().
 *
 * Manage creation of region/Market/service/localtarget pages via taxonomy additions
 */
function sprowt_taxonomy_engine_taxonomy_term_insert($term) {
	$allowed_vocabs = array('regions', 'services', 'markets');
	if (in_array($term->vocabulary_machine_name, $allowed_vocabs)) {
		//Handle creation of Region nodes first, as they are simpler and not directly tied to LTPs
		if ($term->vocabulary_machine_name == 'regions') {
			$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('region', $term->tid);
			if (empty($nids)) {
				//Create Region node
				$properties = array(
					'title' => $term->name,
					'regions_tid' => $term->tid,
				);

				if ($newNode = _sprowt_taxonomy_engine_build_node('region', $properties)) {
					node_save($newNode);
					watchdog('sprowt_taxonomy_engine', 'Created Region node '.$newNode->nid.' ('.$newNode->title.')');
				}
				else { //function returns NULL if malformed!
					watchdog('sprowt_taxonomy_engine', 'Failed to create Region node (title: '.$properties['title'].'). Check node properties.', array(), WATCHDOG_ERROR);
				}
			}
			else { //Submit watchdog error, something's wonky in the DB!
				watchdog('sprowt_taxonomy_engine', 'Attempting to insert regions term that\'s already linked to existing region node! Alert administrator.', array(), WATCHDOG_ERROR);
			}
			return; //Break out of function, no LTP processing necessary!
		}

		//If a service term, determine whether associated Service node exists. If not, create it
		if ($term->vocabulary_machine_name == 'services') {
			$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('service', $term->tid);
			if (empty($nids)) {
				//Create new Service node
				$properties = array(
					'title' => $term->name,
					'services_tid' => $term->tid,
				);
				if ($newNode = _sprowt_taxonomy_engine_build_node('service', $properties)) {
					node_save($newNode);
					watchdog('sprowt_taxonomy_engine', 'Created Service node '.$newNode->nid.' ('.$newNode->title.')');
				}
				else { //function returns NULL if malformed!
					watchdog('sprowt_taxonomy_engine', 'Failed to create Service node (title: '.$properties['title'].'). Check node properties.', array(), WATCHDOG_ERROR);
					return;
				}
			}
			else { //Submit watchdog error, something's wonky in the DB!
				watchdog('sprowt_taxonomy_engine', 'Attempting to insert services term that\'s already linked to existing service node! Alert administrator.', array(), WATCHDOG_ERROR);
			}
		}
		elseif ($term->vocabulary_machine_name == 'markets') { //Do the same for Markets
			$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('market', $term->tid);
			if (empty($nids)) {
				//Create new Market node
				$properties = array(
					'title' => $term->name,
					'markets_tid' => $term->tid,
				);
				if ($newNode = _sprowt_taxonomy_engine_build_node('market', $properties)) {
					node_save($newNode);
					watchdog('sprowt_taxonomy_engine', 'Created Market node '.$newNode->nid.' ('.$newNode->title.')');
				}
				else { //function returns NULL if malformed!
					watchdog('sprowt_taxonomy_engine', 'Failed to create Market node (title: '.$properties['title'].'). Check node properties.', array(), WATCHDOG_ERROR);
					return;
				}
			}
			else { //Submit watchdog error, something's wonky in the DB!
				watchdog('sprowt_taxonomy_engine', 'Attempting to insert Markets term that\'s already linked to existing Market node! Alert administrator.', array(), WATCHDOG_ERROR);
			}
		}

		//Now, handle the creation of LocalTarget nodes
		$ltp_data = _sprowt_taxonomy_engine_get_existing_ltps(TRUE);
		$ltp_lookup_table = $ltp_data['ltp_lookup_table'];

		$all_service_terms = taxonomy_get_tree(taxonomy_vocabulary_machine_name_load('services')->vid);
		$all_market_terms = taxonomy_get_tree(taxonomy_vocabulary_machine_name_load('markets')->vid);
		foreach ($all_service_terms as $this_service_term) {
			foreach ($all_market_terms as $this_market_term) {
				if (!isset($ltp_lookup_table[$this_service_term->tid][$this_market_term->tid])) {
					//Create new LTP!
					$properties = array(
						'title' => $this_service_term->name.' in '.$this_market_term->name,
						'services_tid' => $this_service_term->tid,
						'markets_tid' => $this_market_term->tid,
					);
					if ($newNode = _sprowt_taxonomy_engine_build_node('localtarget', $properties)) {
						node_save($newNode);
						watchdog('sprowt_taxonomy_engine', 'Created LocalTarget node '.$newNode->nid.' ('.$newNode->title.')');
					}
					else { //function returns NULL if malformed!
						watchdog('sprowt_taxonomy_engine', 'Failed to create LocalTarget node (title: '.$properties['title'].'). Check node properties.', array(), WATCHDOG_ERROR);
						return;
					}					
				}
			}
		}
	}	
}

/**
 * Implements hook_taxonomy_term_delete().
 *
 * Manage deletion of appropriate nodes based on term deletion
 */
function sprowt_taxonomy_engine_taxonomy_term_delete($term) {
	if ($term->vocabulary_machine_name == 'services' || $term->vocabulary_machine_name == 'markets') {
		//First, delete LocalTarget pages
		$nids = _sprowt_taxonomy_engine_get_existing_ltps();
		foreach (node_load_multiple($nids) as $node) {
			if ($term->vocabulary_machine_name == 'services' && $node->field_service['und'][0]['tid'] == $term->tid) {
				$nid = $node->nid;
				$title = $node->title;
				node_delete($node->nid);
				watchdog('sprowt_taxonomy_engine', 'Deleted LocalTarget node '.$nid.' ('.$title.')');
			}
			elseif ($term->vocabulary_machine_name == 'markets' && $node->field_market['und'][0]['tid'] == $term->tid) {
				$nid = $node->nid;
				$title = $node->title;
				node_delete($node->nid);
				watchdog('sprowt_taxonomy_engine', 'Deleted LocalTarget node '.$nid.' ('.$title.')');
			}
		}
		//Second, delete actual service page if a services taxonomy term
		if ($term->vocabulary_machine_name == 'services') {
			$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('service', $term->tid);
			foreach (node_load_multiple($nids) as $node) {
				$nid = $node->nid;
				$title = $node->title;
				node_delete($node->nid);
				watchdog('sprowt_taxonomy_engine', 'Deleted Service node '.$nid.' ('.$title.')');
			}
		}
		elseif ($term->vocabulary_machine_name == 'markets') { //Third, delete Market page if a Markets taxonomy term
			$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('market', $term->tid);
			foreach (node_load_multiple($nids) as $node) {
				$nid = $node->nid;
				$title = $node->title;
				node_delete($node->nid);
				watchdog('sprowt_taxonomy_engine', 'Deleted Market node '.$nid.' ('.$title.')');
			}
		}
	}
	elseif ($term->vocabulary_machine_name == 'regions') {  //Delete region separately, as it has no direct relationship with LTPs
		$nids = _sprowt_taxonomy_engine_get_associated_nids_by_tid('region', $term->tid);
		foreach (node_load_multiple($nids) as $node) {
			$nid = $node->nid;
			$title = $node->title;
			node_delete($node->nid);
			watchdog('sprowt_taxonomy_engine', 'Deleted Region node '.$nid.' ('.$title.')');
		}
	}
}


/*BEGIN HELPER FUNCTIONS*/

//Helper function to return lorem ipsum dummy content
function _sprowt_taxonomy_engine_get_dummy_content($field_name = '') {
	switch ($field_name) {
		case '':
		default:
			return 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';
	}
}

//Helper function to pull service node ids associated with a service term tid (should only ever pull one though if everything is functioning correctly!)
//$type = machine name of content type you're retriving
//$tid = term id that you want matched within instance of content type
function _sprowt_taxonomy_engine_get_associated_nids_by_tid($type, $tid) {
	$allowed_types = array('service', 'market', 'region');
	$nids = array();
	if (is_numeric($tid) && in_array($type, $allowed_types)) {
		switch ($type) {
			case 'service':
				$table = 'field_data_field_service';
				$table_alias = 's';
				$tid_column = 'field_service_tid';
				break;
			case 'market':
				$table = 'field_data_field_market';
				$table_alias = 'm';
				$tid_column = 'field_market_tid';
				break;
			case 'region':
				$table = 'field_data_field_region';
				$table_alias = 'r';
				$tid_column = 'field_region_tid';
				break;
		}
		$result = db_query("SELECT n.nid from {node} n
			LEFT JOIN {$table} $table_alias ON n.nid=$table_alias.entity_id
			WHERE n.type=:type AND $table_alias.$tid_column=:tid", 
			array(':type'=>$type, ':tid'=>$tid));
		$nids = $result->fetchCol();
	}
	
	return $nids;
}

//Helper function to pull local target related data from the database
function _sprowt_taxonomy_engine_get_existing_ltps($includeLTPLookupTable = FALSE) {
	$queryString = 'SELECT n.nid';
	if ($includeLTPLookupTable) {
		$queryString .= ', s.field_service_tid, m.field_market_tid';
	}
	$queryString .= ' FROM {node} n
		LEFT JOIN {field_data_field_service} s ON n.nid=s.entity_id
		LEFT JOIN {field_data_field_market} m on n.nid=m.entity_id
		WHERE n.type=:type';
	$result = db_query($queryString, array(':type'=>'localtarget'));

	if (!$includeLTPLookupTable) {
		$nids = array_values($result->fetchCol());
		return array_combine($nids, $nids);
	}
	else {
		$nids = array();
		$ltp_lookup_table = array();
		foreach ($result as $row) {
			$nids[$row->nid] = $row->nid;
			$ltp_lookup_table[$row->field_service_tid][$row->field_market_tid] = 'placeholder';
		}
		return array('nids' => $nids, 'ltp_lookup_table' => $ltp_lookup_table);
	}
}

//Helper function to create new instances of nodes
//Currently supported $properties keys:
//title - The title of the node (Required for all nodes!)
//regions_tid - The tid of the regions term to be set as the node's term reference (Required for Region nodes!)
//services_tid - The tid of the services term to be set as the node's term reference (Required for Service and LocalTarget nodes!)
//markets_tid - The tid of the markets term to be set as the node's term reference (Required for Market and LocalTarget nodes!)
function _sprowt_taxonomy_engine_build_node($type = '', $properties = array()) {
	$allowable_node_types = array('region', 'service', 'market', 'localtarget');

	if (in_array($type, $allowable_node_types)) {
		$node = new StdClass();
		$node->type = $type;
		$node->language = LANGUAGE_NONE;
		node_object_prepare($node);
		$node->status = 0;
		//Consider moving to switch statement if we want to vary dummy content!
		$node->body[$node->language][0]['value'] = _sprowt_taxonomy_engine_get_dummy_content();
		$node->body[$node->language][0]['format'] = 'filtered_html';
		if (isset($properties['title'])) {
			$node->title = $properties['title'];
		}
		else {
			return NULL;
		}
		switch ($type) {
			case 'region':
				if (isset($properties['regions_tid']) && is_numeric($properties['regions_tid'])) {
					$node->field_region[$node->language][0]['tid'] = $properties['regions_tid'];
				}
				else {
					return NULL;
				}
				break;
			case 'service':
				if (isset($properties['services_tid']) && is_numeric($properties['services_tid'])) {
					$node->field_service[$node->language][0]['tid'] = $properties['services_tid'];
				}
				else {
					return NULL;
				}
				break;
			case 'market':
				if (isset($properties['markets_tid']) && is_numeric($properties['markets_tid'])) {
					$node->field_market[$node->language][0]['tid'] = $properties['markets_tid'];
				}
				else {
					return NULL;
				}
				break;
			case 'localtarget':
				if (isset($properties['services_tid']) && is_numeric($properties['services_tid'])) {
					$node->field_service[$node->language][0]['tid'] = $properties['services_tid'];
				}
				else {
					return NULL;
				}
				if (isset($properties['markets_tid']) && is_numeric($properties['markets_tid'])) {
					$node->field_market[$node->language][0]['tid'] = $properties['markets_tid'];
				}
				else {
					return NULL;
				}
				break;
		}
		return $node;
	}
	else {
		return NULL;
	}
}

/**
 * Implements hook_node_update(). Hooks into when the node is being updated.
 * This is for moving a service, market, region, or localtarget into and out
 * of the main menu when published.
 * 
 * @param Node $node The node object
 * 
 * @return void
 */
function sprowt_taxonomy_engine_node_update($node) {
	$allowable_node_types = array('region', 'service', 'market', 'localtarget');
	if (in_array($node->type, $allowable_node_types) && $node->original->status != $node->status) {
		$entities = array_values(entity_uuid_load('node', array('c1c20802-54d4-49c2-ad31-61784e121b9f','2b054fc1-1268-405d-9d93-9829b7c4a20c')));
		foreach($entities as $e){
			switch($e->uuid){
				case 'c1c20802-54d4-49c2-ad31-61784e121b9f':
					$services = _sprowt_taxonomy_engine_add_menu_info($e);
					break;
				case '2b054fc1-1268-405d-9d93-9829b7c4a20c':
					$service_areas = _sprowt_taxonomy_engine_add_menu_info($e);
					break;
			}
		}
		
		// Act on the unpublishing of an article.
		if ($node->status == 0) {
			$node->menu['enabled'] = 0;
			menu_node_save($node);
		}
		// Act on the publishing of an article.
		if ($node->status == 1 && empty($node->menu['enabled'])) {
			$region_count = db_query("SELECT count(nid) FROM {node} WHERE type = 'region' AND status = 1")->fetchField();
			switch($node->type){
				case 'region':
					if(!empty($region_count) && $region_count > 1){
						$node->menu = array(
							'link_title' => $node->title,
							'menu_name' => 'main-menu',
							'plid' => $service_areas->menu['mlid'],
							'enabled' => 1,
							'description' => $node->title,
						);
					}
					break;
				case 'market':
					if(!empty($region_count) && $region_count > 1){
						$region = _sprowt_taxonomy_engine_get_market_parent_region($node->nid);
						if(!empty($region->nid)){
							if(empty($region->menu['mlid'])){
								$region->menu = array(
									'link_title' => $region->title,
									'menu_name' => 'main-menu',
									'plid' => $service_areas->menu['mlid'],
									'enabled' => 1,
									'description' => $node->title,
								);
								menu_node_save($region);
							}
							$node->menu = array(
								'link_title' => $node->title,
								'menu_name' => 'main-menu',
								'plid' => $region->menu['mlid'],
								'enabled' => 1,
								'description' => $node->title,
							);
						}
					}
					else {
						$node->menu = array(
							'link_title' => $node->title,
							'menu_name' => 'main-menu',
							'plid' => $service_areas->menu['mlid'],
							'enabled' => 1,
							'description' => $node->title,
						);
					}
					break;
				case 'service':
					$node->menu = array(
						'link_title' => $node->title,
						'menu_name' => 'main-menu',
						'plid' => $services->menu['mlid'],
						'enabled' => 1,
						'description' => $node->title,
					);
					break;
				case 'localtarget':
					$market =  _sprowt_taxonomy_engine_get_localtarget_parent_market($node->nid);
					if(!empty($market->menu['mlid'])){
						$node->menu = array(
							'link_title' => $node->title,
							'menu_name' => 'main-menu',
							'plid' => $market->menu['mlid'],
							'enabled' => 1,
							'description' => $node->title,
						);
					}
					break;
			}
			menu_node_save($node);
		}
	}
}

/**
 * Returns the node object for the parent region of a market
 * 
 * @param int $nid Market nid
 * 
 * @return Node    node object of the parent region;
 */
function _sprowt_taxonomy_engine_get_market_parent_region($nid){
	$q = db_query("
		SELECT r.entity_id as 'entity_id'
		FROM {field_data_field_region} r
		JOIN {field_data_field_markets} f on f.entity_id=r.field_region_tid
		JOIN {field_data_field_market} m on m.field_market_tid=f.field_markets_tid
		JOIN {node} n on n.nid=r.entity_id
		WHERE m.entity_id = :nid
		AND f.entity_type = 'taxonomy_term'
		AND f.bundle = 'regions'
		AND r.bundle = 'region'
		AND n.status = 1
	", array(':nid' => $nid))->fetchAll(PDO::FETCH_ASSOC);
	
	$nids = array();
	foreach($q as $row){
		$nids[] = $row['entity_id'];
	}
	return _sprowt_taxonomy_engine_add_menu_info(node_load($nids[0]));
}

/**
 * Returns the node object for the parent market of a localtarget
 * 
 * @param int $nid Localtarget nid
 * 
 * @return Node    node object of the parent market;
 */
function _sprowt_taxonomy_engine_get_localtarget_parent_market($nid){
	$q = db_query("
		SELECT m.entity_id as 'entity_id'
		FROM {field_data_field_market} m
		JOIN {field_data_field_market} l on m.field_market_tid=l.field_market_tid
		JOIN {node} n on m.entity_id=n.nid
		WHERE l.entity_id = :nid
		AND m.entity_type = 'node'
		AND m.bundle = 'market'
		AND l.bundle = 'localtarget'
		AND n.status = 1
	", array(':nid' => $nid))->fetchAll(PDO::FETCH_ASSOC);
	
	$nids = array();
	foreach($q as $row){
		$nids[] = $row['entity_id'];
	}
	return _sprowt_taxonomy_engine_add_menu_info(node_load($nids[0]));
}

/**
 * Adds menu info to a node object
 * 
 * @param Node $node node object
 * 
 * @return Node Node object with menu info added
 */
function _sprowt_taxonomy_engine_add_menu_info($node){
	if(empty($node->menu)){
		$menu = db_query("SELECT * FROM {menu_links} WHERE link_path = :link", array(':link' => "node/{$node->nid}"))->fetchAssoc();
		$node->menu = $menu;
	}
	
	return $node;
}

function _sprowt_service_term_map(){
    $map = &drupal_static(__FUNCTION__);

    if(!isset($map)) {
        $map = db_query("
            SELECT s.field_service_tid, n.nid
            FROM node n
            LEFT JOIN field_data_field_service s on s.entity_id = n.nid AND s.entity_type = 'node'
            WHERE n.type = 'service'
            GROUP BY n.nid
		")->fetchAllKeyed();
    }

    return $map;
}


function _sprowt_market_term_map(){
    $map = &drupal_static(__FUNCTION__);

    if(!isset($map)) {
        $map = db_query("
            SELECT m.field_market_tid, n.nid
            FROM node n
            LEFT JOIN field_data_field_market m on m.entity_id = n.nid AND m.entity_type = 'node'
            WHERE n.type = 'market'
            GROUP BY n.nid
		")->fetchAllKeyed();
    }

    return $map;
}
/**
 * Get the service node from a service tid
 */
function _sprowt_service_node_from_tid($tid) {
    $map = _sprowt_service_term_map();
	$nid = $map[$tid];
	
	return node_load($nid);
}

/**
 * Get the market node from a market tid
 */
function _sprowt_market_node_from_tid($tid) {
    $map = _sprowt_market_term_map();
	$nid = $map[$tid];
	
	return node_load($nid);
}

/**
 * Implements hook_token_info().
 */
function sprowt_taxonomy_engine_token_info() {
    $types = array(
        'sprowt_node' => array(
            'name' => 'Sprowt Node',
            'description' => 'Sprowt specific tokens',
            'needs-data' => 'node'
        ),
    );


    $tokens = array(
        'sprowt_node' => array(
            'localtarget_url_pattern' => array(
                'name' => 'Localtarget URL pattern',
                'description' => 'then ending url pattern for Localtarget pages in the form of "service-market-state"',
            )
        ),
    );

    if (module_exists('node')) {
        $tokens['node']['sprowt_node'] = array(
            'name' => t('Sprowt Node'),
            'description' => t('Sprowt specific tokens'),
            'type' => 'sprowt_node',
        );
    }
    return array(
        'types' => $types,
        'tokens' => $tokens
    );
}

function _sprowt_taxonomy_engine_slugify($str) {
    $str = strtolower($str);

    return preg_replace('/[^a-z\-]/','-', $str);

}


/**
 * Implements hook_tokens().
 */
function sprowt_taxonomy_engine_tokens($type, $tokens, array $data = array(), array $options = array()) {
    $replacements = array();
    if(!empty($data['node'])) {
        $node = $data['node'];

        foreach($tokens as $name => $original) {
            switch($name) {
                case 'sprowt_node:localtarget_url_pattern':
                case 'localtarget_url_pattern':
                    if($node->type == 'localtarget') {
                        $market = _sprowt_market_node_from_tid($node->field_market[LANGUAGE_NONE][0]['tid']);
                        $service = _sprowt_service_node_from_tid($node->field_service[LANGUAGE_NONE][0]['tid']);

                        $state = $market->field_state[LANGUAGE_NONE][0]['value'];

                        if(empty($state)) {
                            $nid = db_query("
                                SELECT entity_id
                                FROM field_data_field_market
                                WHERE field_market_tid = :tid
                                AND bundle = 'location'
                            ", array(
                                ':tid' => $node->field_market[LANGUAGE_NONE][0]['tid']
                            ))->fetchField();
                            if(!empty($nid)) {
                                $location = node_load($nid);
                                $state = $location->field_state[LANGUAGE_NONE][0]['value'];
                            }
                        }

                        $url = array(
                            _sprowt_taxonomy_engine_slugify($service->title),
                            _sprowt_taxonomy_engine_slugify($market->title),
                            _sprowt_taxonomy_engine_slugify($state),
                        );

                        foreach($url as $k => $v) {
                            if(empty($v)) {
                                unset($url[$k]);
                            }
                        }

                        $url = array_values($url);

                        $replacements[$original] = implode('-', $url);
                    }
                    break;
            }
        }
    }

    return $replacements;
}